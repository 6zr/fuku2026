<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VW1EHGZ7WM"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-VW1EHGZ7WM');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FKS - Evolution</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0; overflow: hidden; background: #000;
            font-family: 'Impact', 'Arial Black', sans-serif; touch-action: none;
            color: white; user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI共通 */
        .ui-overlay {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
            justify-content: space-between; padding: 20px; z-index: 10;
        }

        /* 命令ボックス */
        .instruction-box {
            background: rgba(220, 38, 38, 0.9); padding: 10px 20px;
            border-radius: 4px; border: 3px solid #fff;
            text-align: center; font-size: 1.1rem; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            transform: skewX(-10deg);
            margin-top: 20px;
        }

        /* スコア表示（左上） */
        .stats-container { position: absolute; top: 20px; left: 20px; text-align: left; }
        .score-label { font-size: 0.8rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
        .score-value { font-size: 2.2rem; font-weight: 900; font-style: italic; line-height: 1; }

        /* プログレスバー */
        #progress-container {
            width: 80%; max-width: 300px; height: 16px; background: #333;
            border-radius: 0; overflow: hidden; opacity: 0;
            transition: opacity 0.5s; margin-bottom: 20px; border: 2px solid #fff;
            transform: skewX(-15deg);
        }
        #progress-bar {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, #fbbf24, #fff);
            box-shadow: 0 0 20px #fbbf24;
        }

        /* タイマー表示 */
        #time-display {
            position: absolute; top: 80px; font-size: 4rem;
            font-weight: 900; color: #fff; opacity: 0; font-style: italic;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* 結果画面 */
        #result-screen {
            position: absolute; inset: 0; background: radial-gradient(circle, #1e40af, #000);
            display: none; flex-direction: column; align-items: center;
            justify-content: center; pointer-events: auto; z-index: 100;
            padding: 20px; text-align: center;
            overflow-y: auto;
        }
        .rank-text {
            font-size: 18vw; max-font-size: 8rem; font-weight: 900; margin: 10px 0;
            color: #fff; text-shadow: 4px 4px 0 #ef4444; transform: skewX(-10deg);
            line-height: 1;
        }
        @media (min-width: 600px) { .rank-text { font-size: 8rem; } }

        /* 特殊プロンプト */
        #aa-prompt {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3.5rem; color: #fbbf24; font-weight: 900; font-style: italic;
            text-shadow: 0 0 15px #000, 0 0 30px #fbbf24; display: none; z-index: 60;
            animation: pulse 0.1s infinite alternate;
            background: rgba(0,0,0,0.8); padding: 15px 30px; border: 6px solid #fbbf24;
            pointer-events: none; width: 80%; text-align: center;
        }
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1.0); }
            to { transform: translate(-50%, -50%) scale(1.1); }
        }

        .flash { position: absolute; inset: 0; background: white; pointer-events: none; opacity: 0; z-index: 50; }
    </style>
</head>
<body>

<div id="flash-effect" class="flash"></div>
<div id="aa-prompt">ADJUST!!</div>

<div class="ui-overlay">
    <div class="stats-container">
        <div class="score-label" id="score-label-text">RESPECT</div>
        <div id="score-display" class="score-value">0</div>
    </div>
    <div id="time-display">0.0</div>
    <div id="instruction" class="instruction-box">TAP TO START</div>
    
    <div id="progress-container">
        <div id="progress-bar"></div>
    </div>
</div>

<div id="result-screen">
    <div class="score-label" id="final-score-label" style="font-size: 1rem;">TOTAL RESPECT</div>
    <div id="final-score" class="score-value" style="font-size: 3.5rem; margin-bottom: 5px;">0</div>
    <div id="rank-display" class="rank-text">U C ME</div>
    <div id="rank-desc" class="mb-6 text-white font-bold text-center px-4 italic text-lg leading-tight">"HUSTLE, LOYALTY, RESPECT"</div>
    
    <button id="retry-btn" class="bg-red-600 hover:bg-red-500 text-white font-black py-3 px-12 text-xl rounded-none transform skew-x-[-15deg] transition-all active:scale-95 border-4 border-white mb-6">REMATCH</button>

    <footer class="text-slate-400 text-xs flex flex-col items-center pt-4 pb-6">
        <div class="mb-4">
            <a href="../" class="flex items-center hover:text-slate-600 transition-colors bg-white px-4 py-2 rounded-full shadow-sm border border-slate-100 text-slate-900 font-bold">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                </svg>
                トップへもどる
            </a>
        </div>
        <p>© 2026 6zr / fuku2026</p>
    </footer>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const AudioEngine = {
        ctx: null,
        mainGain: null,
        loopId: null,
        currentPhase: -1,
        
        async init() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.mainGain = this.ctx.createGain();
                this.mainGain.gain.value = 0.2;
                this.mainGain.connect(this.ctx.destination);
            }
            if (this.ctx.state === 'suspended') {
                await this.ctx.resume();
            }
        },

        playNote(freq, start, duration, type = 'sawtooth', volume = 0.5) {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, start);
            
            g.gain.setValueAtTime(0, start);
            g.gain.linearRampToValueAtTime(volume, start + 0.05);
            g.gain.exponentialRampToValueAtTime(0.01, start + duration);
            
            osc.connect(g);
            g.connect(this.mainGain);
            
            osc.start(start);
            osc.stop(start + duration);
        },

        // Phase 0: デーーンデーーンデーーンデーン
        playIntro() {
            if (this.currentPhase === 0) return;
            this.init();
            this.currentPhase = 0;
            
            const now = this.ctx.currentTime;
            // 低音の D2 (73.42Hz)
            const notes = [196.00, 174.61, 155.56, 146.83, 196.00, 174.61, 155.56, 146.83,];
            notes.forEach((f, i) => {
                this.playNote(f, now + (i * 1.2), 1.1, 'sawtooth', 1.2);
            });
        },

        // Phase 1+: チャッチャラッチャー
        startMainLoop() {
            this.init();
            if (this.currentPhase === 1) return;
            this.currentPhase = 1;
            
            if (this.loopId) clearInterval(this.loopId);
            
            const playMotive = () => {
                const now = this.ctx.currentTime;
                // G4, F4, G4, A4, G4
                const motive = [
					{f: 392.00, d: 0.20, t: 0.0},  // チャッ (Bb4)
					{f: 440.00, d: 0.10, t: 0.4},  // チャ   (A4)
					{f: 349.23, d: 0.10, t: 0.6},  // ラッ   (F4)
					{f: 392.00, d: 0.40, t: 1.0},  // チャ〜 (G4) ← 低く着地

					{f: 466.16, d: 0.20, t: 2.0},  // チャッ (G4)
					{f: 440.00, d: 0.10, t: 2.4},  // チャ   (A4)
					{f: 349.23, d: 0.10, t: 2.6},  // ラッ   (F4)
					{f: 392.00, d: 0.40, t: 3.0},  // チャ〜 (G4) ← 低く着地
                ];
                motive.forEach(n => this.playNote(n.f, now + n.t, n.d, 'square', 1.4));
            };

            playMotive();
            this.loopId = setInterval(playMotive, 4000);
        },

        stop() {
            if (this.loopId) clearInterval(this.loopId);
            if (this.ctx) this.ctx.close();
            this.ctx = null;
            this.currentPhase = -1;
        }
    };
    const GAME_CONFIG = {
        assets: {
            face: 'https://6zr.github.io/fuku2026/cena/images/face.png',
            handRaise: 'https://6zr.github.io/fuku2026/cena/images/hand_raise.png',
            handShuffle: 'https://6zr.github.io/fuku2026/cena/images/hand_shuffle.png',
            aa: 'https://6zr.github.io/fuku2026/cena/images/aa.png'
        },
        text: {
            scoreLabel: "RESPECT",
            startInstruction: "HUSTLE, LOYALTY, RESPECT",
            phase1Instruction: "集中してエナジーを高めろ!",
            phase2Instruction: "手を振ってSHUFFLE！",
            phase3Instruction: "READY...",
            phase3Action: "ロングタップで解き放て！",
            aaPrompt: "決めろ！",
            aaFinish1: "ATTITUDE",
            aaFinish2: "ADJUSTMENT",
            retryBtn: "REMATCH",
            rankDesc: '"Thank You CENA"',
            feedback: {
                great: "GREAT!",
                good: "GOOD",
                miss: "MISS...",
                hustle: "HUSTLE!",
                fks: "FKS!!",
                aaSuccess: "U CAN'T C ME!!"
            }
        },
        balance: {
            phase2TimeLimit: 3.0,
            aaWindowFrames: 20,
            phase3MaxBonus: 8000,
            phase3StopPenalty: 30,
            phase3HoldPenalty: 80,
            scores: {
                great: 3500,
                good: 1200,
                miss: -500,
                hustle: 150,
                fks: 0,
                aaSuccess: 20000
            }
        },
        ranks: [
            { threshold: 31000, name: "G.O.A.T." },
            { threshold: 25000, name: "CHAMP" },
            { threshold: 10000, name: "SOLDIER" },
            { threshold: 0,     name: "ROOKIE" }
        ]
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const instruction = document.getElementById('instruction');
    const progressBar = document.getElementById('progress-bar');
    const progressContainer = document.getElementById('progress-container');
    const scoreDisplay = document.getElementById('score-display');
    const timeDisplay = document.getElementById('time-display');
    const resultScreen = document.getElementById('result-screen');
    const finalScoreDisplay = document.getElementById('final-score');
    const rankDisplay = document.getElementById('rank-display');
    const flashEffect = document.getElementById('flash-effect');
    const retryBtn = document.getElementById('retry-btn');
    const aaPrompt = document.getElementById('aa-prompt');

    document.getElementById('score-label-text').innerText = GAME_CONFIG.text.scoreLabel;
    document.getElementById('final-score-label').innerText = "TOTAL " + GAME_CONFIG.text.scoreLabel;
    document.getElementById('rank-desc').innerText = GAME_CONFIG.text.rankDesc;
    instruction.innerText = GAME_CONFIG.text.startInstruction;
    aaPrompt.innerText = GAME_CONFIG.text.aaPrompt;
    retryBtn.innerText = GAME_CONFIG.text.retryBtn;

    const assets = {};
    Object.keys(GAME_CONFIG.assets).forEach(key => {
        assets[key] = new Image();
        assets[key].src = GAME_CONFIG.assets[key];
    });

    let width, height;
    let phase = 0; 
    let isPressing = false;
    let timer = 0, limitTimer = GAME_CONFIG.balance.phase2TimeLimit, waitTimer = 0;
    let charX = 0, charY = 0, charRotation = 0, charScale = 1, shake = 0;
    let totalScore = 0;
    let feedbackText = "", feedbackTimer = 0;
    let transitionLock = false;

    let charDirection = -1, hasReachedLeft = false, hasReachedFinal = false;
    let touchStartX = 0, lastSwipeDir = 0, handX = 0, handY = 0, handSpeed = 0;
    let slamStage = 0, slamProgress = 0, aaTriggerActive = false, aaWindowTimer = 0;
    let hitStop = 0;
    let ripple = { x: 0, y: 0, size: 0, active: false };
    let p3Bonus = GAME_CONFIG.balance.phase3MaxBonus;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
        charX = width / 2;
        charY = height * 0.6;
    }

    function triggerFlash(intensity = 0.8, color = 'white') {
        flashEffect.style.backgroundColor = color;
        flashEffect.style.transition = 'none';
        flashEffect.style.opacity = intensity;
        setTimeout(() => {
            flashEffect.style.transition = 'opacity 0.8s';
            flashEffect.style.opacity = '0';
        }, 50);
    }

    function updateScore(amount) {
        totalScore += amount;
        scoreDisplay.innerText = Math.floor(totalScore);
    }

    function showFeedback(text, scoreBonus = 0) {
        feedbackText = text;
        feedbackTimer = 60;
        if (scoreBonus !== 0) updateScore(scoreBonus);
    }

    function drawAsset(img, x, y, targetW, targetH, rotation = 0, scale = 1, alpha = 1) {
        if (!img.complete || img.naturalWidth === 0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = "#555";
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            ctx.fillRect(-targetW/2, -targetH/2, targetW, targetH);
            ctx.restore();
            return;
        }
        const aspectRatio = img.naturalHeight / img.naturalWidth;
        const drawW = targetW;
        const drawH = targetW * aspectRatio;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.scale(scale, scale);
        ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
        ctx.restore();
    }

    async function onDown(e) {
        if (waitTimer > 0 || resultScreen.style.display === 'flex') return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        if (phase === 4 && aaTriggerActive) {
            phase = 5; aaTriggerActive = false; aaPrompt.style.display = 'none';
            slamStage = 0; slamProgress = 0; hitStop = 15;
            triggerFlash(1.0, '#fbbf24');
            showFeedback(GAME_CONFIG.text.feedback.aaSuccess, GAME_CONFIG.balance.scores.aaSuccess);
            shake = 100;
            ripple = { x: clientX, y: clientY, size: 0, active: true };
            return;
        }

        if (transitionLock) return;
        isPressing = true;
        touchStartX = clientX;

        if (phase === 0) {
        	// 音源の初期化とPhase0再生
        	await AudioEngine.init();
            AudioEngine.playIntro();

            phase = 1;
            instruction.innerText = GAME_CONFIG.text.phase1Instruction;
            triggerFlash(0.3); hitStop = 4;
        } else if (phase === 1) {
            const p = (timer % 1.8) / 1.8;
            if (p > 0.82 && p < 0.98) {
                triggerFlash(0.6); showFeedback(GAME_CONFIG.text.feedback.great, GAME_CONFIG.balance.scores.great);
                waitTimer = 40; hitStop = 8;
            } else if (p > 0.65 && p < 0.99) {
                showFeedback(GAME_CONFIG.text.feedback.good, GAME_CONFIG.balance.scores.good);
                waitTimer = 35; hitStop = 4;
            } else {
                showFeedback(GAME_CONFIG.text.feedback.miss, GAME_CONFIG.balance.scores.miss);
                waitTimer = 30; shake = 5;
            }
        }
    }

    function onMove(e) {
        if (phase === 2 && isPressing && !transitionLock) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const diff = clientX - touchStartX;
            if (Math.abs(diff) > 20) {
                if (diff * lastSwipeDir <= 0) {
                    timer += 0.12;
                    showFeedback(GAME_CONFIG.text.feedback.hustle, GAME_CONFIG.balance.scores.hustle);
                    handSpeed = (diff > 0 ? 1 : -1) * 45;
                    lastSwipeDir = diff > 0 ? 1 : -1;
                    shake = 12;
                }
                touchStartX = clientX;
            }
        }
    }

    function onUp() {
        if (phase === 3 && !transitionLock) {
            if (hasReachedFinal) {
                showFeedback(GAME_CONFIG.text.feedback.fks, Math.max(0, p3Bonus));
                transitionLock = true; phase = 4; slamStage = 0; slamProgress = 0;
                triggerFlash(0.5); hitStop = 5;
            }
        }
        isPressing = false;
    }

    function update() {
        if (hitStop > 0) { hitStop--; requestAnimationFrame(update); return; }
        ctx.clearRect(0, 0, width, height);
        const sX = (Math.random() - 0.5) * shake;
        const sY = (Math.random() - 0.5) * shake;
        if (shake > 0) shake *= 0.92;

        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, phase >= 4 ? '#4c1d95' : '#001a4d'); 
        bgGrad.addColorStop(1, '#000');
        ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, width, height);

        // const assetBaseSize = Math.min(width, height) * 0.5;
        const assetBaseSize = (height <= width) ? height * 0.25 : width * 0.5;

        switch(phase) {
            case 0:
            case 1:
                if (phase === 1 && waitTimer === 0) timer += 0.025;
                drawAsset(assets.face, charX + sX, charY + sY, assetBaseSize, assetBaseSize * 1.3);
                drawAsset(assets.handRaise, charX + sX + 60, charY + sY - 60, assetBaseSize * 0.6, assetBaseSize * 0.6, -0.2, 1.1);
                if (phase === 1) {
                    const p = (timer % 1.8) / 1.8;
                    const targetY = height * 0.4;
                    ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth = 5;
                    ctx.beginPath(); ctx.arc(width/2, targetY, 50, 0, Math.PI*2); ctx.stroke();
                    const ringR = 50 + (250 - 50) * (1 - p);
                    ctx.strokeStyle = (p > 0.8) ? "#fbbf24" : "rgba(255,255,255,0.5)";
                    ctx.beginPath(); ctx.arc(width/2, targetY, ringR, 0, Math.PI*2); ctx.stroke();
                    if (waitTimer > 0) {
                        if (waitTimer === 1) {
                            phase = 2; timer = 0; 
							AudioEngine.stop();
							AudioEngine.startMainLoop();
							limitTimer = GAME_CONFIG.balance.phase2TimeLimit;
                            instruction.innerText = GAME_CONFIG.text.phase2Instruction;
                            progressContainer.style.opacity = 1; timeDisplay.style.opacity = 1;
                        }
                        waitTimer--;
                    }
                }
                break;
            case 2:
                if (waitTimer === 0 && !transitionLock) {
                    limitTimer -= 1/60;
                    if (timer > 0) timer -= 0.003;
                }
                timeDisplay.innerText = Math.max(0, limitTimer).toFixed(1);
                progressBar.style.width = (Math.min(1, timer) * 100) + "%";
                handX += handSpeed; handSpeed *= 0.82; handX *= 0.8;
                const alpha = Math.min(1, timer * 2.0);
                drawAsset(assets.face, charX + sX, charY + sY, assetBaseSize, assetBaseSize * 1.3, 0, 1, alpha);
                drawAsset(assets.handShuffle, charX + sX + handX, charY + sY - 40, assetBaseSize * 0.7, assetBaseSize * 0.7, handSpeed * 0.02, 1.2, alpha);
                if ((timer >= 1.0 || limitTimer <= 0) && !transitionLock) {
                    transitionLock = true; waitTimer = 60;
                    instruction.innerText = GAME_CONFIG.text.phase3Instruction;
                    timeDisplay.style.opacity = 0; progressContainer.style.opacity = 0;
                    isPressing = false; triggerFlash(0.4);
                }
                if (waitTimer > 0) {
                    if (waitTimer === 1) {
                        phase = 3; charX = width / 2; transitionLock = false;
                        charDirection = -1; hasReachedLeft = false; hasReachedFinal = false;
                        instruction.innerText = GAME_CONFIG.text.phase3Action;
                        p3Bonus = GAME_CONFIG.balance.phase3MaxBonus;
                    }
                    waitTimer--;
                }
                break;
            case 3:
                if (!transitionLock) {
                    const centerX = width / 2;
                    if (isPressing) {
                        if (!hasReachedFinal) {
                            charX += 18 * charDirection;
                            if (charX <= 80) { charX = 80; charDirection = 1; hasReachedLeft = true; }
                            if (hasReachedLeft && charX >= centerX) { charX = centerX; hasReachedFinal = true; }
                        } else {
                            p3Bonus -= GAME_CONFIG.balance.phase3HoldPenalty;
                            shake = Math.max(shake, 3);
                        }
                    } else {
                        if (!hasReachedFinal) p3Bonus -= GAME_CONFIG.balance.phase3StopPenalty;
                    }
                }
                drawAsset(assets.face, charX + sX, charY + sY, assetBaseSize, assetBaseSize * 1.3);
                if (p3Bonus < GAME_CONFIG.balance.phase3MaxBonus * 0.8) {
                    ctx.fillStyle = "#ef4444"; ctx.font = "italic 400 24px Impact"; ctx.textAlign = "center";
                    ctx.fillText(`BONUS: ${Math.floor(Math.max(0, p3Bonus))}`, width/2, height * 0.15);
                }
                break;
            case 4:
                if (slamStage === 0) {
                    slamProgress += 0.04; charY -= 6;
                    charRotation = -Math.PI * 0.15 * slamProgress;
                    charScale = 1 + slamProgress * 0.6;
                    if (slamProgress >= 1) { slamStage = 1; slamProgress = 0; }
                } else if (slamStage === 1) {
                    slamProgress += 0.08; charY += 50;
                    charRotation = -Math.PI * 0.15 + (Math.PI * 0.4 * slamProgress);
                    if (charY >= height * 0.9) {
                        charY = height * 0.9; slamStage = 2; slamProgress = 0; hitStop = 10;
                        triggerFlash(0.6); shake = 50; aaTriggerActive = true;
                        aaWindowTimer = GAME_CONFIG.balance.aaWindowFrames;
                        aaPrompt.style.display = 'block';
                    }
                } else if (slamStage === 2) {
                    if (aaWindowTimer > 0) {
                        aaWindowTimer--; shake = Math.max(shake, 10);
                        if (aaWindowTimer === 0) {
                            aaTriggerActive = false; aaPrompt.style.display = 'none';
                            setTimeout(showResult, 800);
                        }
                    }
                }
                drawAsset(assets.face, charX + sX, charY + sY, assetBaseSize, assetBaseSize * 1.3, charRotation, charScale);
                break;
            case 5:
                if (slamStage === 0) {
                    slamProgress += 0.05; charY -= 20;
                    charRotation = Math.PI * 6 * slamProgress;
                    charScale = 2.0 + slamProgress * 1.5;
                    if (slamProgress >= 1) { slamStage = 1; slamProgress = 0; }
                } else if (slamStage === 1) {
                    slamProgress += 0.15; charY += 120; charRotation = Math.PI * 0.5;
                    if (charY >= height * 0.95) {
                        charY = height * 0.95; slamStage = 2; triggerFlash(1.0, '#fff'); shake = 200;
                        setTimeout(showResult, 2200);
                    }
                } else {
                    charRotation = Math.PI * 1.0; charScale = 3.5;
                    ctx.fillStyle = "#fbbf24"; ctx.font = `italic 900 ${Math.min(width * 0.15, 80)}px Impact`; ctx.textAlign = "center";
                    ctx.shadowBlur = 40; ctx.shadowColor = "white";
                    ctx.fillText(GAME_CONFIG.text.aaFinish1, width/2, height/2 - 50);
                    ctx.fillText(GAME_CONFIG.text.aaFinish2, width/2, height/2 + 50);
                    ctx.shadowBlur = 0;
                }
                drawAsset(assets.aa, charX + sX, charY + sY, assetBaseSize, assetBaseSize * 1.3, charRotation, charScale);
                break;
        }

        if (ripple.active) {
            ripple.size += 35;
            ctx.strokeStyle = `rgba(255, 255, 255, ${1 - ripple.size/900})`;
            ctx.lineWidth = 25;
            ctx.beginPath(); ctx.arc(ripple.x, ripple.y, ripple.size, 0, Math.PI*2); ctx.stroke();
            if (ripple.size > 900) ripple.active = false;
        }

        if (feedbackTimer > 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${feedbackTimer/60})`;
            ctx.font = `italic 900 ${Math.min(width * 0.18, 75)}px Impact`; ctx.textAlign = "center";
            ctx.fillText(feedbackText, width/2, height * 0.25);
            feedbackTimer--;
        }
        requestAnimationFrame(update);
    }

    function showResult() {
		AudioEngine.stop();
        resultScreen.style.display = 'flex';
        finalScoreDisplay.innerText = Math.floor(totalScore);
        let rankName = GAME_CONFIG.ranks[GAME_CONFIG.ranks.length - 1].name;
        for (const rank of GAME_CONFIG.ranks) {
            if (totalScore >= rank.threshold) { rankName = rank.name; break; }
        }
        rankDisplay.innerText = rankName;
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMove(e); }, {passive: false});
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchend', onUp);
        retryBtn.addEventListener('click', () => location.reload());
        requestAnimationFrame(update);
    }
    init();
</script>
</body>
</html>
