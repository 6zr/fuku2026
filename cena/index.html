<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VW1EHGZ7WM"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-VW1EHGZ7WM');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FKS - Evolution</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0; overflow: hidden; background: #000;
            font-family: 'Impact', 'Arial Black', sans-serif; touch-action: none;
            color: white; user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        .ui-overlay {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
            justify-content: space-between; padding: 40px 20px; z-index: 10;
        }
        .instruction-box {
            background: rgba(220, 38, 38, 0.9); padding: 12px 30px;
            border-radius: 4px; border: 3px solid #fff;
            text-align: center; font-size: 1.2rem; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            transform: skewX(-10deg);
        }
        .stats-container { position: absolute; top: 40px; left: 20px; text-align: left; }
        .score-label { font-size: 0.9rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
        .score-value { font-size: 3rem; font-weight: 900; font-style: italic; }
        
        #progress-container {
            width: 80%; max-width: 400px; height: 20px; background: #333;
            border-radius: 0; overflow: hidden; opacity: 0;
            transition: opacity 0.5s; margin-bottom: 20px; border: 3px solid #fff;
            transform: skewX(-15deg);
        }
        #progress-bar {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, #fbbf24, #fff);
            box-shadow: 0 0 20px #fbbf24;
        }
        #time-display {
            position: absolute; top: 120px; font-size: 5rem;
            font-weight: 900; color: #fff; opacity: 0; font-style: italic;
        }
        #result-screen {
            position: absolute; inset: 0; background: radial-gradient(circle, #1e40af, #000);
            display: none; flex-direction: column; align-items: center;
            justify-content: center; pointer-events: auto; z-index: 100;
        }
        .rank-text {
            font-size: 8rem; font-weight: 900; margin: -10px 0;
            color: #fff; text-shadow: 5px 5px 0 #ef4444; transform: skewX(-10deg);
        }
        .flash { position: absolute; inset: 0; background: white; pointer-events: none; opacity: 0; z-index: 50; }
        
        #aa-prompt {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 5rem; color: #fbbf24; font-weight: 900; font-style: italic;
            text-shadow: 0 0 15px #000, 0 0 30px #fbbf24; display: none; z-index: 60;
            animation: pulse 0.1s infinite alternate;
            background: rgba(0,0,0,0.8); padding: 20px 40px; border: 8px solid #fbbf24;
            pointer-events: none;
        }
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1.1); }
            to { transform: translate(-50%, -50%) scale(1.2); }
        }
    </style>
</head>
<body>

<div id="flash-effect" class="flash"></div>
<div id="aa-prompt">ADJUST!!</div>

<div class="ui-overlay">
    <div class="stats-container">
        <div class="score-label" id="score-label-text">RESPECT</div>
        <div id="score-display" class="score-value">0</div>
    </div>
    <div id="time-display">5.0</div>
    <div id="instruction" class="instruction-box">TAP TO START</div>
    
    <div id="progress-container">
        <div id="progress-bar"></div>
    </div>
</div>

<div id="result-screen">
    <div class="score-label" id="final-score-label">TOTAL RESPECT</div>
    <div id="final-score" class="score-value" style="font-size: 4rem; margin-bottom: 10px;">0</div>
    <div id="rank-display" class="rank-text">U C ME</div>
    <div id="rank-desc" class="mb-8 text-white font-bold text-center px-4 italic text-xl">"HUSTLE, LOYALTY, RESPECT"</div>
    <button id="retry-btn" class="bg-red-600 hover:bg-red-500 text-white font-black py-4 px-16 text-2xl rounded-none transform skew-x-[-15deg] transition-all active:scale-95 border-4 border-white">REMATCH</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    /**
     * Game Config
     */
    const GAME_CONFIG = {
        assets: {
            face: 'https://6zr.github.io/fuku2026/images/face.png',
            handL: 'https://6zr.github.io/fuku2026/images/hand_l.png',
            handR: 'https://6zr.github.io/fuku2026/images/hand_r.png',
            bodyFull: 'https://6zr.github.io/fuku2026/images/mikan.png'
        },
        text: {
            scoreLabel: "RESPECT",
            startInstruction: "HUSTLE, LOYALTY, RESPECT",
            phase1Instruction: "集中してエナジーを高めろ!",
            phase2Instruction: "手を振ってSHUFFLE！",
            phase3Instruction: "READY...",
            phase3Action: "ロングタップで解き放て！",
            aaPrompt: "決めろ！",
            aaFinish1: "ATTITUDE",
            aaFinish2: "ADJUSTMENT",
            retryBtn: "REMATCH",
            rankDesc: '"Thank You CENA"',
            feedback: {
                great: "GREAT!",
                good: "GOOD",
                miss: "MISS...",
                hustle: "HUSTLE!",
                fks: "FKS!!",
                aaSuccess: "YOU CAN'T SEE ME!!"
            }
        },
        balance: {
            phase2TimeLimit: 3.0,
            aaWindowFrames: 20,
            scores: {
                great: 2000,
                good: 800,
                miss: -100,
                hustle: 100,
                fks: 5000,
                aaSuccess: 15000
            }
        },
        ranks: [
            { threshold: 25000, name: "G.O.A.T." },
            { threshold: 15000, name: "CHAMP" },
            { threshold: 0,     name: "SOLDIER" }
        ]
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const instruction = document.getElementById('instruction');
    const progressBar = document.getElementById('progress-bar');
    const progressContainer = document.getElementById('progress-container');
    const scoreDisplay = document.getElementById('score-display');
    const timeDisplay = document.getElementById('time-display');
    const resultScreen = document.getElementById('result-screen');
    const finalScoreDisplay = document.getElementById('final-score');
    const rankDisplay = document.getElementById('rank-display');
    const flashEffect = document.getElementById('flash-effect');
    const retryBtn = document.getElementById('retry-btn');
    const aaPrompt = document.getElementById('aa-prompt');

    // UI Labels
    document.getElementById('score-label-text').innerText = GAME_CONFIG.text.scoreLabel;
    document.getElementById('final-score-label').innerText = "TOTAL " + GAME_CONFIG.text.scoreLabel;
    document.getElementById('rank-desc').innerText = GAME_CONFIG.text.rankDesc;
    instruction.innerText = GAME_CONFIG.text.startInstruction;
    aaPrompt.innerText = GAME_CONFIG.text.aaPrompt;
    retryBtn.innerText = GAME_CONFIG.text.retryBtn;

    // Asset Loading
    const assets = {};
    Object.keys(GAME_CONFIG.assets).forEach(key => {
        assets[key] = new Image();
        assets[key].src = GAME_CONFIG.assets[key];
    });

    let width, height;
    let phase = 0; 
    let isPressing = false;
    let timer = 0, limitTimer = GAME_CONFIG.balance.phase2TimeLimit, waitTimer = 0;
    let charX = 0, charY = 0, charRotation = 0, charScale = 1, shake = 0;
    let totalScore = 0;
    let feedbackText = "", feedbackTimer = 0;
    let transitionLock = false;

    let charDirection = -1, hasReachedLeft = false, hasReachedFinal = false;
    let touchStartX = 0, lastSwipeDir = 0, handX = 0, handY = 0, handSpeed = 0;
    let slamStage = 0, slamProgress = 0, aaTriggerActive = false, aaWindowTimer = 0;
    let hitStop = 0;
    let ripple = { x: 0, y: 0, size: 0, active: false };

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
        charX = width / 2;
        charY = height * 0.6;
    }

    function triggerFlash(intensity = 0.8, color = 'white') {
        flashEffect.style.backgroundColor = color;
        flashEffect.style.transition = 'none';
        flashEffect.style.opacity = intensity;
        setTimeout(() => {
            flashEffect.style.transition = 'opacity 0.8s';
            flashEffect.style.opacity = '0';
        }, 50);
    }

    function updateScore(amount) {
        totalScore += amount;
        scoreDisplay.innerText = Math.floor(totalScore);
    }

    function showFeedback(text, scoreBonus = 0) {
        feedbackText = text;
        feedbackTimer = 60;
        if (scoreBonus !== 0) updateScore(scoreBonus);
    }

    /**
     * 画像の縦横比を維持して描画する関数
     */
    function drawAsset(img, x, y, targetW, targetH, rotation = 0, scale = 1, alpha = 1) {
        if (!img.complete || img.naturalWidth === 0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = "#555";
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            ctx.fillRect(-targetW/2, -targetH/2, targetW, targetH);
            ctx.restore();
            return;
        }

        // アスペクト比を維持するための計算
        const aspectRatio = img.naturalHeight / img.naturalWidth;
        const drawW = targetW;
        const drawH = targetW * aspectRatio; // 幅を基準に高さを決める

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.scale(scale, scale);
        ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
        ctx.restore();
    }

    function onDown(e) {
        if (waitTimer > 0 || resultScreen.style.display === 'flex') return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        if (phase === 4 && aaTriggerActive) {
            phase = 5; aaTriggerActive = false; aaPrompt.style.display = 'none';
            slamStage = 0; slamProgress = 0; hitStop = 15;
            triggerFlash(1.0, '#fbbf24');
            showFeedback(GAME_CONFIG.text.feedback.aaSuccess, GAME_CONFIG.balance.scores.aaSuccess);
            shake = 100;
            ripple = { x: clientX, y: clientY, size: 0, active: true };
            return;
        }

        if (transitionLock) return;
        isPressing = true;
        touchStartX = clientX;

        if (phase === 0) {
            phase = 1;
            instruction.innerText = GAME_CONFIG.text.phase1Instruction;
            triggerFlash(0.3); hitStop = 4;
        } else if (phase === 1) {
            const p = (timer % 1.8) / 1.8;
            if (p > 0.82 && p < 0.98) {
                triggerFlash(0.6); showFeedback(GAME_CONFIG.text.feedback.great, GAME_CONFIG.balance.scores.great);
                waitTimer = 40; hitStop = 8;
            } else if (p > 0.65 && p < 0.99) {
                showFeedback(GAME_CONFIG.text.feedback.good, GAME_CONFIG.balance.scores.good);
                waitTimer = 35; hitStop = 4;
            } else {
                showFeedback(GAME_CONFIG.text.feedback.miss, GAME_CONFIG.balance.scores.miss);
                waitTimer = 30; shake = 5;
            }
        }
    }

    function onMove(e) {
        if (phase === 2 && isPressing && !transitionLock) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const diff = clientX - touchStartX;
            if (Math.abs(diff) > 20) {
                if (diff * lastSwipeDir <= 0) {
                    timer += 0.12;
                    showFeedback(GAME_CONFIG.text.feedback.hustle, GAME_CONFIG.balance.scores.hustle);
                    handSpeed = (diff > 0 ? 1 : -1) * 45;
                    lastSwipeDir = diff > 0 ? 1 : -1;
                    shake = 12;
                }
                touchStartX = clientX;
            }
        }
    }

    function onUp() {
        if (phase === 3 && !transitionLock) {
            if (hasReachedFinal) {
                showFeedback(GAME_CONFIG.text.feedback.fks, GAME_CONFIG.balance.scores.fks);
                transitionLock = true; phase = 4; slamStage = 0; slamProgress = 0;
                triggerFlash(0.5); hitStop = 5;
            }
        }
        isPressing = false;
    }

    function update() {
        if (hitStop > 0) { hitStop--; requestAnimationFrame(update); return; }
        ctx.clearRect(0, 0, width, height);
        
        const sX = (Math.random() - 0.5) * shake;
        const sY = (Math.random() - 0.5) * shake;
        if (shake > 0) shake *= 0.92;

        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, phase >= 4 ? '#4c1d95' : '#001a4d'); 
        bgGrad.addColorStop(1, '#000');
        ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, width, height);

        switch(phase) {
            case 0:
            case 1:
                if (phase === 1 && waitTimer === 0) timer += 0.025;
                drawAsset(assets.face, charX + sX, charY + sY, 200, 260);
                drawAsset(assets.handL, charX + sX + 60, charY + sY - 60, 130, 130, -0.2, 1.1);

                if (phase === 1) {
                    const p = (timer % 1.8) / 1.8;
                    const targetY = height * 0.4;
                    ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth = 5;
                    ctx.beginPath(); ctx.arc(width/2, targetY, 50, 0, Math.PI*2); ctx.stroke();
                    const ringR = 50 + (250 - 50) * (1 - p);
                    ctx.strokeStyle = (p > 0.8) ? "#fbbf24" : "rgba(255,255,255,0.5)";
                    ctx.beginPath(); ctx.arc(width/2, targetY, ringR, 0, Math.PI*2); ctx.stroke();
                    
                    if (waitTimer > 0) {
                        if (waitTimer === 1) {
                            phase = 2; timer = 0; limitTimer = GAME_CONFIG.balance.phase2TimeLimit;
                            instruction.innerText = GAME_CONFIG.text.phase2Instruction;
                            progressContainer.style.opacity = 1; timeDisplay.style.opacity = 1;
                        }
                        waitTimer--;
                    }
                }
                break;
                
            case 2:
                if (waitTimer === 0 && !transitionLock) {
                    limitTimer -= 1/60;
                    if (timer > 0) timer -= 0.003;
                }
                timeDisplay.innerText = Math.max(0, limitTimer).toFixed(1);
                progressBar.style.width = (Math.min(1, timer) * 100) + "%";
                handX += handSpeed; handSpeed *= 0.82; handX *= 0.8;
                
                const alpha = Math.min(1, timer * 2.0);
                drawAsset(assets.face, charX + sX, charY + sY, 200, 260, 0, 1, alpha);
                drawAsset(assets.handR, charX + sX + handX, charY + sY - 40, 140, 140, handSpeed * 0.02, 1.2, alpha);

                if ((timer >= 1.0 || limitTimer <= 0) && !transitionLock) {
                    transitionLock = true; waitTimer = 60;
                    instruction.innerText = GAME_CONFIG.text.phase3Instruction;
                    timeDisplay.style.opacity = 0; progressContainer.style.opacity = 0;
                    isPressing = false; triggerFlash(0.4);
                }
                if (waitTimer > 0) {
                    if (waitTimer === 1) {
                        phase = 3; charX = width / 2; transitionLock = false;
                        charDirection = -1; hasReachedLeft = false; hasReachedFinal = false;
                        instruction.innerText = GAME_CONFIG.text.phase3Action;
                    }
                    waitTimer--;
                }
                break;

            case 3:
                if (!transitionLock) {
                    const centerX = width / 2;
                    if (isPressing && !hasReachedFinal) {
                        charX += 18 * charDirection;
                        if (charX <= 80) { charX = 80; charDirection = 1; hasReachedLeft = true; }
                        if (hasReachedLeft && charX >= centerX) { charX = centerX; hasReachedFinal = true; }
                    }
                }
                drawAsset(assets.face, charX + sX, charY + sY, 200, 260);
                break;

            case 4:
                if (slamStage === 0) {
                    slamProgress += 0.04; charY -= 6;
                    charRotation = -Math.PI * 0.15 * slamProgress;
                    charScale = 1 + slamProgress * 0.6;
                    if (slamProgress >= 1) { slamStage = 1; slamProgress = 0; }
                } else if (slamStage === 1) {
                    slamProgress += 0.08; charY += 50;
                    charRotation = -Math.PI * 0.15 + (Math.PI * 0.4 * slamProgress);
                    if (charY >= height * 0.9) {
                        charY = height * 0.9; slamStage = 2; slamProgress = 0; hitStop = 10;
                        triggerFlash(0.6); shake = 50; aaTriggerActive = true;
                        aaWindowTimer = GAME_CONFIG.balance.aaWindowFrames;
                        aaPrompt.style.display = 'block';
                    }
                } else if (slamStage === 2) {
                    if (aaWindowTimer > 0) {
                        aaWindowTimer--; shake = Math.max(shake, 10);
                        if (aaWindowTimer === 0) {
                            aaTriggerActive = false; aaPrompt.style.display = 'none';
                            setTimeout(showResult, 800);
                        }
                    }
                }
                drawAsset(assets.face, charX + sX, charY + sY, 200, 260, charRotation, charScale);
                break;

            case 5:
                if (slamStage === 0) {
                    slamProgress += 0.05; charY -= 20;
                    charRotation = Math.PI * 6 * slamProgress;
                    charScale = 2.0 + slamProgress * 1.5;
                    if (slamProgress >= 1) { slamStage = 1; slamProgress = 0; }
                } else if (slamStage === 1) {
                    slamProgress += 0.15; charY += 120; charRotation = Math.PI * 0.5;
                    if (charY >= height * 0.95) {
                        charY = height * 0.95; slamStage = 2; triggerFlash(1.0, '#fff'); shake = 200;
                        setTimeout(showResult, 2200);
                    }
                } else {
                    charRotation = Math.PI * 1.0; charScale = 3.5;
                    ctx.fillStyle = "#fbbf24"; ctx.font = "italic 900 85px Impact"; ctx.textAlign = "center";
                    ctx.shadowBlur = 40; ctx.shadowColor = "white";
                    ctx.fillText(GAME_CONFIG.text.aaFinish1, width/2, height/2 - 50);
                    ctx.fillText(GAME_CONFIG.text.aaFinish2, width/2, height/2 + 50);
                    ctx.shadowBlur = 0;
                }
                drawAsset(assets.bodyFull, charX + sX, charY + sY, 200, 260, charRotation, charScale);
                break;
        }

        if (ripple.active) {
            ripple.size += 35;
            ctx.strokeStyle = `rgba(255, 255, 255, ${1 - ripple.size/900})`;
            ctx.lineWidth = 25;
            ctx.beginPath(); ctx.arc(ripple.x, ripple.y, ripple.size, 0, Math.PI*2); ctx.stroke();
            if (ripple.size > 900) ripple.active = false;
        }

        if (feedbackTimer > 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${feedbackTimer/60})`;
            ctx.font = "italic 900 75px Impact"; ctx.textAlign = "center";
            ctx.fillText(feedbackText, width/2, height * 0.25);
            feedbackTimer--;
        }

        requestAnimationFrame(update);
    }

    function showResult() {
        resultScreen.style.display = 'flex';
        finalScoreDisplay.innerText = Math.floor(totalScore);
        let rankName = GAME_CONFIG.ranks[GAME_CONFIG.ranks.length - 1].name;
        for (const rank of GAME_CONFIG.ranks) {
            if (totalScore >= rank.threshold) { rankName = rank.name; break; }
        }
        rankDisplay.innerText = rankName;
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMove(e); }, {passive: false});
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchend', onUp);
        retryBtn.addEventListener('click', () => location.reload());
        requestAnimationFrame(update);
    }

    init();
</script>
</body>
</html>
